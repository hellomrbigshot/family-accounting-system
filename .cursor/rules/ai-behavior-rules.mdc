---
description: AI 行为约束规则
globs: 
alwaysApply: true
---
# AI 行为约束规则

## 代码修改原则

### 1. 不主动重构代码
- **原则**：除非用户明确要求，否则不主动重构现有代码
- **行为**：只修改用户明确指定的代码部分
- **例外**：修复明显的语法错误或安全问题
- **示例**：
  ```javascript
  // ✅ 正确：只修改用户指定的函数
  function getUserInfo() {
    // 用户要求修改的部分
  }
  
  // ❌ 错误：主动重构其他函数
  function otherFunction() {
    // 不应该主动修改
  }
  ```

### 2. 不修改提问无关的代码
- **原则**：严格限制修改范围，只处理与用户问题直接相关的代码
- **行为**：在修改前明确说明要修改的文件和具体位置
- **验证**：确保每个修改都与用户问题直接相关
- **示例**：
  ```javascript
  // ✅ 正确：只修改用户关心的部分
  // 用户问："如何修复这个函数的错误？"
  function targetFunction() {
    // 只修改这个函数
  }
  
  // ❌ 错误：修改无关代码
  function unrelatedFunction() {
    // 不应该修改
  }
  ```

### 3. 文件长度控制
- **原则**：单个文件不超过500行
- **行为**：如果文件超过500行，建议拆分为多个文件
- **拆分策略**：
  - 按功能模块拆分
  - 提取公共组件
  - 分离业务逻辑和UI逻辑
- **示例**：
  ```javascript
  // 如果文件超过500行，建议拆分：
  // - components/UserList.vue (UI组件)
  // - composables/useUser.js (业务逻辑)
  // - utils/userHelpers.js (工具函数)
  ```

## 分析原则

### 4. 从系统整体分析
- **原则**：分析问题时考虑整个系统的架构和依赖关系
- **行为**：
  - 分析代码的依赖关系
  - 考虑修改对系统其他部分的影响
  - 评估性能和安全性影响
  - 考虑向后兼容性
- **分析维度**：
  - 数据流向
  - 组件依赖关系
  - API接口影响
  - 状态管理影响
  - 用户体验影响

**系统分析示例：**
```javascript
// 分析用户问题："如何优化这个组件的性能？"
// 1. 分析组件依赖
// 2. 检查数据流向
// 3. 评估性能瓶颈
// 4. 考虑缓存策略
// 5. 分析用户交互模式
```

## 解决方案原则

### 5. 提供多个解决方案
- **原则**：当存在多个可行解决方案时，提供多个选项供用户选择
- **行为**：
  - 列出所有可行的解决方案
  - 说明每个方案的优缺点
  - 提供选择建议
  - 说明实施复杂度
- **方案对比格式**：

**方案A：简单快速**
- 优点：实施简单，风险低
- 缺点：可能不是最优解
- 适用场景：快速修复，临时方案

**方案B：完整重构**
- 优点：彻底解决问题，性能最优
- 缺点：实施复杂，风险较高
- 适用场景：长期维护，性能要求高

**方案C：渐进式改进**
- 优点：平衡了简单性和完整性
- 缺点：可能需要多次迭代
- 适用场景：中等复杂度，需要平衡

## 实施指南

### 修改前检查清单
1. ✅ 确认用户明确要求修改
2. ✅ 识别需要修改的具体文件和位置
3. ✅ 分析修改对系统的影响
4. ✅ 检查文件长度是否超过500行
5. ✅ 评估是否有多个解决方案

### 修改时行为规范
1. **明确说明**：清楚说明要修改的内容和原因
2. **最小化修改**：只修改必要的部分
3. **保持一致性**：遵循项目的代码风格
4. **添加注释**：为复杂修改添加说明
5. **测试建议**：提供测试建议

### 修改后验证
1. **功能验证**：确保修改解决了用户问题
2. **影响评估**：确认没有破坏其他功能
3. **代码质量**：确保代码符合项目规范
4. **文档更新**：必要时更新相关文档

## 示例场景

### 场景1：用户要求修复特定函数
```javascript
// 用户问题："修复 getUserInfo 函数的错误"
// ✅ 正确做法：
// 1. 只修改 getUserInfo 函数
// 2. 分析函数依赖关系
// 3. 提供修复方案
// 4. 说明修改影响

// ❌ 错误做法：
// 1. 重构整个文件
// 2. 修改无关函数
// 3. 改变文件结构
```

### 场景2：性能优化需求
```javascript
// 用户问题："优化这个组件的性能"
// ✅ 正确做法：
// 1. 分析性能瓶颈
// 2. 提供多个优化方案
// 3. 说明每个方案的优缺点
// 4. 让用户选择最适合的方案

// ❌ 错误做法：
// 1. 直接实施单一方案
// 2. 不考虑系统影响
// 3. 不提供选择
```

### 场景3：文件过长问题
```javascript
// 用户问题："这个文件太长了，怎么办？"
// ✅ 正确做法：
// 1. 分析文件结构
// 2. 提供拆分方案
// 3. 说明拆分策略
// 4. 提供实施步骤

// ❌ 错误做法：
// 1. 直接开始重构
// 2. 不考虑拆分影响
// 3. 不提供多个方案
```

## 总结

这些规则的核心目标是：
- **精确性**：只修改用户明确要求的部分
- **可控性**：确保修改不会产生意外影响
- **可维护性**：保持代码结构清晰
- **系统性**：从整体角度考虑问题
- **选择性**：为用户提供多个解决方案选择

遵循这些规则可以确保AI的代码修改行为更加可控、精确和有用。
